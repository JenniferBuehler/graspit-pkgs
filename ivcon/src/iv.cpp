#include "ivconv.h"

bool IVCONV::iv_read ( FILE *filein )

/******************************************************************************/

/*
Purpose:

IV_READ reads graphics information from an Inventor file.

Example:

#Inventor V2.0 ascii

Separator {
Info {
string "Inventor file generated by IVCON.
Original data in file cube.iv."
}
Separator {
LightModel {
model PHONG
}
MatrixTransform { matrix
0.9  0.0  0.0  0.0
0.0 -0.9  0.0  0.0
0.0  0.0 -1.5  0.0
0.0  0.0  0.0  1.0
}
Material {
ambientColor  0.2 0.2 0.2
diffuseColor  [
0.8 0.8 0.8,
0.7 0.1 0.1,
0.1 0.8 0.2,
]
emissiveColor 0.0 0.0 0.0
specularColor 0.0 0.0 0.0
shininess     0.2
transparency  [
0.0, 0.5, 1.0,
]
}
Texture2 {
filename      "fred.rgb"
wrapS         REPEAT
wrapT         REPEAT
model         MODULATE
blendColor    0.0 0.0 0.0
}

MaterialBinding {
value PER_VERTEX_INDEXED
}
NormalBinding {
value PER_VERTEX_INDEXED
}
TextureCoordinateBinding {
value PER_VERTEX_INDEXED
}

ShapeHints {
vertexOrdering COUNTERCLOCKWISE
shapeType UNKNOWN_SHAPE_TYPE
faceType CONVEX
creaseAngle 6.28319
}

Coordinate3 {
point [
8.59816       5.55317      -3.05561,
8.59816       2.49756      0.000000E+00,
...etc...
2.48695       2.49756      -3.05561,
]
}

Normal {
vector [
0.71 0.71 0.0,
...etc...
0.32 0.32 0.41,
]
}

TextureCoordinate2 {
point [
0.0  1.0,
0.1, 0.8,
...etc...
0.4  0.7,
]
}

IndexedLineSet {
coordIndex [
0,    1,    2,   -1,
3,    4,    5,   -1,
7,    8,    9,   -1,
...etc...
189,  190,  191,   -1,
]
materialIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
}

IndexedFaceSet {
coordIndex [
0,    1,    2,   -1,
3,    4,    5,   -1,
7,    8,    9,   -1,
...etc...
189,  190,  191,   -1,
]
materialIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
normalIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
textureCoordIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
}

IndexedTriangleStripSet {
vertexProperty VertexProperty {
vertex [ x y z,
...
x y z ]
normal [ x y z,
...
x y z ]
materialBinding OVERALL
normalBinding PER_VERTEX_INDEXED
}
coordIndex [ 
i, j, k, l, m, -1, 
n, o, p, q, r, s, t, u, -1,
v, w, x, -1 
..., -1 ]
normalIndex -1
}

}
}

Modified:

01 July 1999

Author:

John Burkardt
*/
{
	char  c;
	int   count;
	int   i;
	int   icol;
	int   icolor;
	int   icface;
	int   inormface;
	int   iface_num;
	int   irow;
	int   iuv;
	int   ivert;
	int   iword;
	int   ix;
	int   ixyz;
	int   iy;
	int   iz;
	int   j;
	int   jval;
	int   level;
	char *next;
	int   nlbrack;
	int   nrbrack;
	int   nu;
	int   null_index;
	int   cor3_num_old;
	int   line_num2;
	int   face_num2;
	int   normal_num_temp;
	int   text_numure_temp;
	int   nv;
	int   result;
	float rval;
	int   width;
	char  word[LINE_MAX_LEN];
	char  word1[LINE_MAX_LEN];
	char  wordm1[LINE_MAX_LEN];
	float xvec[3];
	
	icface = 0;
	icol = -1;
	inormface = 0;
	iface_num = face_num;
	irow = 0;
	ix = 0;
	ixyz = 0;
	iy = 0;
	iz = 0;
	jval = 0;
	level = 0;
	strcpy ( level_name[0], "Top" );
	nlbrack = 0;
	nrbrack = 0;
	nu = 0;
	cor3_num_old = cor3_num;
	face_num2 = face_num;
	line_num2 = line_num;
	normal_num_temp = 0;
	text_numure_temp = 0;
	nv = 0;
	rval = 0.0;
	strcpy ( word, " " );
	strcpy ( wordm1, " " );
	/*
	Read the next line of text from the input file.
	*/
	for ( ;; ) {
		char input[LINE_MAX_LEN];
		if ( fgets ( input, LINE_MAX_LEN, filein ) == NULL ) {
			break;
		}
		
		++text_num;
		next = input;
		iword = 0;
		/*
		Remove all commas from the line, so we can use SSCANF to read
		numeric items.
		*/
		i = 0;
		while ( input[i] != '\0' ) {
			if ( input[i] == ',' ) {
				input[i] = ' ';
			}
			++i;
		}
		/*
		Force brackets and braces to be buffered by spaces.
		*/
		i = 0;
		while ( input[i] != '\0' ) {
			++i;
		}
		null_index = i;
		
		i = 0;
		while ( input[i] != '\0' && i < LINE_MAX_LEN ) {
			
			if ( input[i] == '[' || input[i] == ']' || 
				input[i] == '{' || input[i] == '}' ) {
				
				result = char_pad ( &i, &null_index, input, LINE_MAX_LEN );
				if ( result == false ) {
					break;
				}
			} 
			else {
				++i;
			}
		}
		/*
		Read a word from the line.
		*/
		for ( ;; ) {
			
			strcpy ( wordm1, word );
			strcpy ( word, " " );
			
			count = sscanf ( next, "%s%n", word, &width );
			next = next + width;
			
			if ( count <= 0 ) {
				break;
			}
			
			++iword;
			
			if ( iword == 1 ) {
				strcpy ( word1, word );
			}
			/*
			The first line of the file must be the header.
			*/
			if ( text_num == 1 ) {
				
				if ( !leqi ( word1, "#Inventor" ) && !leqi ( word1, "#VRML" )) { 
					printf ( "\n" );
					printf ( "IV_READ - Fatal error!\n" );
					printf ( "  The input file has a bad header.\n" );
					return false;
				}
				else {
					comment_num = comment_num + 1;
				}
				break;
			}
			/*
			A comment begins anywhere with '#'.
			Skip the rest of the line.
			*/
			if ( word[1] == '#' ) {
				comment_num = comment_num + 1;
				break;
			}
			/*
			If the word is a curly or square bracket, count it.
			If the word is a left bracket, the previous word is the name of a node.
			*/
			if ( strcmp ( word, "{" ) == 0 || strcmp ( word, "[" ) == 0 ) {
				nlbrack = nlbrack + 1;
				level = nlbrack - nrbrack;
				strcpy ( level_name[level], wordm1 );
				if ( debug ) {
					printf ( "Begin level: %s\n", wordm1 );
				}
			}
			else if ( strcmp ( word, "}" ) == 0 || strcmp ( word, "]" ) == 0 ) {
				nrbrack = nrbrack + 1;
				
				if ( nlbrack < nrbrack ) {
					printf ( "\n" );
					printf ( "IV_READ - Fatal error!\n" );
					printf ( "  Extraneous right bracket on line %d.\n", text_num );
					printf ( "  Currently processing field %s\n.", level_name[level] );
					return false;
				}
			}
			/*
			BASECOLOR
			*/
			if ( leqi ( level_name[level], "BASECOLOR" )  ) {
				
				if ( strcmp ( word, "{" ) == 0 ) {
				}
				else if ( strcmp ( word, "}" ) == 0 ) {
					level = nlbrack - nrbrack;
				}
				else if ( leqi ( word, "RGB" )  ) {
				}
				else {
					++bad_num;
					printf ( "Bad data %s\n", word );
				}
			}
			/*
			COORDINATE3
			*/
			else if ( leqi ( level_name[level], "COORDINATE3" )  ) {
				
				if ( strcmp ( word, "{" ) == 0 ) {
				}
				else if ( strcmp ( word, "}" ) == 0 ) {
					level = nlbrack - nrbrack;
				}
				else if ( leqi ( word, "POINT" )  ) {
				}
				else {
					++bad_num;
					printf ( "COORDINATE3: Bad data %s\n", word );
				}
			}
			/*
			COORDINATE4
			*/
			else if ( leqi ( level_name[level], "COORDINATE4" )  ) {
				
				if ( strcmp ( word, "{" ) == 0 ) {
				}
				else if ( strcmp ( word, "}" ) == 0 ) {
					level = nlbrack - nrbrack;
				}
				else if ( leqi ( word, "POINT" )  ) {
				}
				else {
					++bad_num;
					printf ( "COORDINATE4: Bad data %s\n", word );
				}
			}
			/*
			COORDINDEX
			*/
			else if ( leqi ( level_name[level], "COORDINDEX" )  ) {
				
				if ( strcmp ( word, "[" ) == 0 ) {
					ivert = 0;
				}
				else if ( strcmp ( word, "]" ) == 0 ) {
					level = nlbrack - nrbrack;
				}
				/*
				(indexedlineset) COORDINDEX
				*/
				else if ( leqi ( level_name[level-1], "INDEXEDLINESET" )  ) {
					
					count = sscanf ( word, "%d%n", &jval, &width );
					
					if ( count > 0 ) {
						
						if ( jval < -1 ) {
							++bad_num;
						}
						else {
							if ( line_num < LINES_MAX ) {
								if ( jval != -1 ) {
									jval = jval + cor3_num_old;
								}
								line_dex[line_num] = jval;
							}
							++line_num;
						}
					}
					else {
						++bad_num;
					}
				}
				/*
				(indexedfaceset) COORDINDEX
				Warning: If the list of indices is not terminated with a final -1, then
				the last face won't get counted.
				*/
				else if ( leqi ( level_name[level-1], "INDEXEDFACESET" )  ) {
					
					count = sscanf ( word, "%d%n", &jval, &width );
					
					if ( count > 0 ) {
						if ( jval == -1 ) {
							ivert = 0;
							++face_num;
						}
						else {
							if ( ivert == 0 ) {
								// if ( face_num < FACE_MAX ) 
								{
									face_order[face_num] = 0;
								}
							}
							// if ( face_num < FACE_MAX ) 
							{
								face_order[face_num] = face_order[face_num] + 1;
								face[ivert][face_num] = jval + cor3_num_old;
								ivert = ivert + 1;
							}
						}
					}
				}
				/*
				(indexednurbssurface) COORDINDEX
				*/
				else if ( leqi ( level_name[level-1], "INDEXEDNURBSSURFACE" )  ) {
				}
				/*
				(indexedtrianglestripset) COORDINDEX
				
				  First three coordinate indices I1, I2, I3 define a triangle.
				  Next triangle is defined by I2, I3, I4 (actually, I4, I3, I2
				  to stay with same counterclockwise sense).
				  Next triangle is defined by I3, I4, I5 ( do not need to reverse
				  odd numbered triangles) and so on.
				  List is terminated with -1.
				*/
				else if ( leqi ( level_name[level-1], "INDEXEDTRIANGLESTRIPSET" )  ) {
					
					count = sscanf ( word, "%d%n", &jval, &width );
					
					if ( count > 0 ) {
						
						if ( jval == -1 ) {
							ivert = 0;
						}
						else {
							
							ix = iy;
							iy = iz;
							iz = jval + cor3_num_old;
							
							if ( ivert == 0 ) {
								// if ( face_num < FACE_MAX ) 
								{
									face[ivert][face_num] = jval + cor3_num_old;
									face_order[face_num] = 3;
								}
							}
							else if ( ivert == 1 ) {
								// if ( face_num < FACE_MAX ) 
								{
									face[ivert][face_num] = jval + cor3_num_old;
								}
							}
							else if ( ivert == 2 ) {
								// if ( face_num < FACE_MAX ) 
								{
									face[ivert][face_num] = jval + cor3_num_old;
								}
								++face_num;
							}
							else {
								
								// if ( face_num < FACE_MAX ) 
								{
									face_order[face_num] = 3;
									if ( ( ivert % 2 ) == 0 ) {
										face[0][face_num] = ix;
										face[1][face_num] = iy;
										face[2][face_num] = iz;
									}
									else {
										face[0][face_num] = iz;
										face[1][face_num] = iy;
										face[2][face_num] = ix;
									}
								}
								++face_num;
							}
							ivert = ivert + 1;
							/*
							Very very tentative guess as to how indices into the normal
							vector array are set up...
							*/
							if (ivert > 2 ) {	//  face_num < FACE_MAX && 
								for ( i = 0; i < 3; ++i ) {
									face_normal[face_num][i] = normal_temp[ix][i];
								}
							}
						}
					}
				}
      }
	  /*
	  INDEXEDFACESET
	  */
      else if ( leqi ( level_name[level], "INDEXEDFACESET" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
			  ivert = 0;
		  }
		  else if ( leqi ( word, "MATERIALINDEX" )  ) {
		  }
		  else if ( leqi ( word, "NORMALINDEX" )  ) {
		  }
		  else if ( leqi ( word, "TEXTURECOORDINDEX" )  ) {
			  if ( texture_num <= 0 ) {
				  texture_num = 1;
				  strcpy ( texture_name[0], "Texture_0000" );
			  }
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INDEXEDLINESET
	  */
      else if ( leqi ( level_name[level], "INDEXEDLINESET" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
		  }
		  else if ( leqi ( word, "MATERIALINDEX" )  ) {
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INDEXEDNURBSSURFACE
	  */
      else if ( leqi ( level_name[level], "INDEXEDNURBSSURFACE" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "NUMUCONTROLPOINTS")  ) {
			  
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
				  nu = jval;
				  if ( debug ) {
					  printf ( "NU = %d\n", nu );
				  }
			  }
			  else {
				  nu = 0;
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  else if ( leqi ( word, "NUMVCONTROLPOINTS" )  ) {
			  
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
				  nv = jval;
				  if ( debug ) {
					  printf ( "NV = %d\n", nv );
				  }
			  }
			  else {
				  nv = 0;
				  ++bad_num;
			  }
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
		  }
		  else if ( leqi ( word, "UKNOTVECTOR" )  ) {
		  }
		  else if ( leqi ( word, "VKNOTVECTOR" )  ) {
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INDEXEDTRIANGLESTRIPSET
	  */
      else if ( leqi ( level_name[level], "INDEXEDTRIANGLESTRIPSET" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VERTEXPROPERTY" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
			  ivert = 0;
		  }
		  else if ( leqi ( word, "NORMALINDEX" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INFO
	  */
      else if ( leqi ( level_name[level], "INFO" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "STRING" )  ) {
		  }
		  else if ( strcmp ( word, "\"" ) == 0 ) {
		  }
		  else {
		  }
      }
	  /*
	  LIGHTMODEL
	  Read, but ignore.
	  */
      else if ( leqi ( level_name[level], "LIGHTMODEL" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "model" )  ) {
		  }
		  else {
		  }
      }
	  /*
	  MATERIAL
	  Read, but ignore.
	  */
      else if ( leqi ( level_name[level],"MATERIAL" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "AMBIENTCOLOR" )  ) {
		  }
		  else if ( leqi ( word, "EMISSIVECOLOR" )  ) {
		  }
		  else if ( leqi ( word, "DIFFUSECOLOR" )  ) {
		  }
		  else if ( leqi ( word, "SHININESS" )  ) {
		  }
		  else if ( leqi ( word, "SPECULARCOLOR" )  ) {
		  }
		  else if ( leqi ( word, "TRANSPARENCY" )  ) {
		  }
		  else {
		  }
      }
	  /*
	  MATERIALBINDING
	  Read, but ignore
	  */
      else if ( leqi ( level_name[level], "MATERIALBINDING" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VALUE" )  ) {
			  count = sscanf ( next, "%s%n", material_binding, &width );
			  next = next + width;
		  }
		  else {
			  count = sscanf ( next, "%f%n", &rval, &width );
			  next = next + width;
			  
			  if ( count > 0 ) {
			  }
			  else {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  }
      }
	  /*
	  MATERIALINDEX
	  */
      else if ( leqi ( level_name[level], "MATERIALINDEX" )  ) {
		  
		  if ( strcmp ( word, "[" ) == 0 ) {
			  ivert = 0;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  /*
		  (indexedfaceset) MATERIALINDEX
		  */
		  else if ( leqi ( level_name[level-1], "INDEXEDFACESET" )  ) {
			  
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
				  
				  if ( jval == -1 ) {
					  ivert = 0;
					  face_num2 = face_num2 + 1;
				  }
				  else {
					  
					  // if ( face_num2 < FACE_MAX ) 
					  {
						  if ( jval != -1 ) {
							  jval = jval + cor3_num_old;
						  }
						  vertex_material[ivert][face_num2] = jval;
						  ivert = ivert + 1;
					  }
				  }
			  }
			  else {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  } 
		  /*
		  (indexedlineset) MATERIALINDEX
		  */
		  else if ( leqi ( level_name[level-1], "INDEXEDLINESET" )  ) {
			  
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
				  
				  if ( line_num2 < LINES_MAX ) {
					  if ( jval != -1 ) {
						  jval = jval + cor3_num_old;
					  }
					  line_material[line_num2] = jval;
					  line_num2 = line_num2 + 1;
				  }
			  }
			  else {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  else {
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
			  }
			  else {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  }
      }
	  /*
	  MATRIXTRANSFORM.
	  */
      else if ( leqi ( level_name[level], "MATRIXTRANSFORM" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "MATRIX" )  ) {
			  icol = -1;
			  irow = 0;
		  }
		  else {
			  
			  count = sscanf ( word, "%f%n", &rval, &width );
			  
			  if ( count > 0 ) {
				  
				  icol = icol + 1;
				  if ( icol > 3 ) {
					  icol = 0;
					  irow = irow + 1;
					  if ( irow > 3 ) {
						  irow = 0;
					  }
				  }
				  
				  transform_matrix[irow][icol] = rval;
			  }
			  
		  }
      }
	  /*
	  NORMAL
	  The field "VECTOR" may be followed by three numbers,
	  (handled here),  or by a square bracket, and sets of three numbers.
	  */
      else if ( leqi ( level_name[level], "NORMAL" )  ) {
	  /*
	  (vertexproperty) NORMAL
		  */
		  if ( leqi ( level_name[level-1], "VERTEXPROPERTY" )  ) {
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  ixyz = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
					  // if ( inormface < FACE_MAX ) 
					  {
						  face_normal[inormface][ixyz] = rval;
					  }
					  
					  ixyz = ixyz + 1;
					  if ( ixyz > 2 ) {
						  ixyz = 0;
						  inormface = inormface + 1;
					  }
				  }
			  }
		  }
		  /*
		  (anythingelse) NORMAL
		  */
		  else {
			  
			  if ( strcmp ( word, "{" ) == 0 ) {
				  ixyz = 0;
			  }
			  else if ( strcmp ( word, "}" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else if ( leqi ( word, "VECTOR" )  ) {
			  }
			  else {
				  
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
				  /*  COMMENTED OUT
				  
					if ( nfnorm < FACE_MAX ) {
					normal[ixyz][nfnorm] = rval;
					}
					
					  */
					  ixyz = ixyz + 1;
					  if ( ixyz > 2 ) {
						  ixyz = 0;
					  }
				  }
				  else {
					  ++bad_num;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
      }
	  /*
	  NORMALBINDING
	  Read, but ignore
	  */
      else if ( leqi ( level_name[level], "NORMALBINDING" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VALUE" )  ) {
			  count = sscanf ( next, "%s%n", normal_binding, &width );
			  next = next + width;
		  }
		  else {
			  count = sscanf ( word, "%f%n", &rval, &width );
			  
			  if ( count > 0 ) {
			  }
			  else {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  }
      }
	  /*
	  NORMALINDEX
	  */
      else if ( leqi ( level_name[level], "NORMALINDEX" )  ) {
	  /*
	  (indexedtrianglestripset) NORMALINDEX
		  */
		  if ( leqi ( level_name[level-1], "INDEXEDTRIANGLESTRIPSET" )  ) {
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
			  }
			  else if ( strcmp ( word, "[" ) == 0 ) {
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
			  }
		  }
		  /*
		  (anythingelse) NORMALINDEX
		  */
		  else {
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  ivert = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  
				  count = sscanf ( word, "%d%n", &jval, &width );
				  
				  if ( count > 0 ) {
					  if ( jval == -1 ) {
						  ivert = 0;
						  iface_num = iface_num + 1;
					  }
					  else {
						  // if ( iface_num < FACE_MAX ) 
						  {
								vertex_normal[ivert][iface_num] = normal_temp[jval];
							  ivert = ivert + 1;
						  }
					  }
				  }
				  else {
					  ++bad_num;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
      }
	  /*
	  (coordinate3) POINT
	  */
      else if ( leqi ( level_name[level], "POINT" )  ) {
		  
		  if ( leqi ( level_name[level-1], "COORDINATE3" )  ) {
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  ixyz = 0;
				  cor3_num_old = cor3_num;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
//					  if ( cor3_num < COR3_MAX ) 
					  {
						  xvec[ixyz] = rval;
					  }
					  
					  ixyz = ixyz + 1;
					  
					  if ( ixyz == 3 ) {
						  
						  ixyz = 0;
						  
						  tmat_mxp ( transform_matrix, xvec, xvec );
						  
						  cor3[cor3_num][0] = xvec[0];
						  cor3[cor3_num][1] = xvec[1];
						  cor3[cor3_num][2] = xvec[2];
						  
						  cor3_num = cor3_num + 1;
						  
						  continue;
					  }
				  }
				  else {
					  ++bad_num;
					  break;
				  }
			  }
		  }
		  /*
		  (texturecoodinate2) POINT
		  */
		  else if ( leqi ( level_name[level-1], "TEXTURECOORDINATE2" )  ) { 
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  iuv = 0;
				  text_numure_temp = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
					  texture_temp[text_numure_temp][iuv] = rval;
					  
					  iuv = iuv + 1;
					  if ( iuv == 2 ) {
						  iuv = 0;
						  text_numure_temp = text_numure_temp + 1;
					  }
				  }
				  else {
					  printf ( "TextureCoordinate2 { Point [: Bad data\n" );
					  ++bad_num;
					  break;
				  }
			  }
		  }
      }
	  /*
	  RGB
	  */
      else if ( leqi ( level_name[level],"RGB" )  ) {
	  /*
	  (basecolor) RGB
		  */
		  if ( leqi ( level_name[level-1], "BASECOLOR" )  ) {
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  icolor = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
					  rgbcolor[color_num][icolor] = rval;
					  icolor = icolor + 1;
					  
					  if ( icolor == 3 ) {
						  icolor = 0;
						  color_num = color_num + 1;
					  }
				  }
				  else {
					  ++bad_num;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
		  /*
		  (anythingelse RGB)
		  */
		  else {
			  
			  printf ( "HALSBAND DES TODES!\n" );
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  icolor = 0;
				  ivert = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
					  // if ( icface < FACE_MAX ) 
					  {
						  
						  vertex_rgb[ivert][icface][icolor] = rval;
						  
						  icolor = icolor + 1;
						  if ( icolor == 3 ) {
							  icolor = 0;
							  color_num = color_num + 1;
							  ivert = ivert + 1;
							  if ( ivert == face_order[icface] ) {
								  ivert = 0;
								  icface = icface + 1;
							  }
						  }
					  }
				  }
				  else {
					  ++bad_num;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
		  
      }
	  /*
	  SEPARATOR
	  */
      else if ( leqi ( level_name[level], "SEPARATOR" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else {
		  }
      }
	  /*
	  SHAPEHINTS
	  Read, but ignore.
	  */
      else if ( leqi ( level_name[level], "SHAPEHINTS" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "CREASEANGLE" )  ) {
			  
			  count = sscanf ( next, "%f%n", &rval, &width );
			  next = next + width;
			  
			  if ( count <= 0 ) {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  else if ( leqi ( word, "FACETYPE" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "SHAPETYPE" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "VERTEXORDERING" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  TEXTURE2
	  */
      else if ( leqi ( level_name[level], "TEXTURE2" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
			  texture_num = texture_num + 1;
		  }
		  else if ( leqi ( word, "BLENDCOLOR" )  ) {
		  }
		  /*
		  NEED TO REMOVE QUOTES SURROUNDING TEXTURE NAME.
		  */
		  else if ( leqi ( word, "FILENAME" )  ) {
			  
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
			  
			  strcpy ( texture_name[texture_num], word );
			  
			  i = 0;
			  j = 0;
			  do {
				  c = texture_name[texture_num][i];
				  i = i + 1;
				  if ( c != '"' ) {
					  texture_name[texture_num][j] = c;
					  j = j + 1;
				  }
			  } while ( c != '\0' );
			  
		  }
		  else if ( leqi ( word, "IMAGE" )  ) {
		  }
		  else if ( leqi ( word, "MODEL" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "WRAPS" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "WRAPT" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
		  }
      }
	  /*
	  TEXTURECOORDINATE2
	  */
      else if ( leqi ( level_name[level], "TEXTURECOORDINATE2" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "POINT" )  ) {
		  }
		  else {
			  ++bad_num;
			  printf ( "TEXTURECOORDINATE2: Bad data %s\n", word );
		  }
      }
	  /*
	  TEXTURECOORDINATEBINDING
	  */
      else if ( leqi ( level_name[level], "TEXTURECOORDINATEBINDING" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VALUE" )  ) {
			  count = sscanf ( next, "%s%n", texture_binding, &width );
			  next = next + width;
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  TEXTURECOORDINDEX
	  */
      else if ( leqi ( level_name[level], "TEXTURECOORDINDEX" )  ) {
		  
		  if ( strcmp ( word, "[" ) == 0 ) {
			  ivert = 0;
			  iface_num = 0;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else {
			  
			  count = sscanf ( word, "%d%n", &jval, &width );
			  
			  if ( count > 0 ) {
				  
				  if ( jval == - 1 ) {
					  ivert = 0;
				  }
				  else {
					  
					  // if ( iface_num < FACE_MAX ) 
					  {
						  vertex_tex_uv[iface_num][ivert] = texture_temp[jval];
					  }
					  
					  ivert = ivert + 1;
					  
					  if ( ivert == face_order[iface_num] ) {
						  ivert = 0;
						  iface_num = iface_num + 1;
					  }
				  }
				  
			  }
			  else {
				  ++bad_num;
				  printf ( "Bad data %s\n", word );
			  }
			  
		  }
      }
	  /*
	  UKNOTVECTOR
	  */
      else if ( leqi ( level_name[level], "UKNOTVECTOR" )  ) {
		  
		  if ( strcmp ( word, "[" ) == 0 ) {
			  continue;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
			  continue;
		  }
		  else {
			  count = sscanf ( word, "%d%n", &jval, &width );
		  }
      }
	  /*
	  VECTOR
	  */
      else if ( leqi ( level_name[level], "VECTOR" )  ) {
		  if ( strcmp ( word, "[" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  /*
		  (normal) VECTOR
		  */
		  else if ( leqi ( level_name[level-1], "NORMAL" )  ) {
			  
			  count = sscanf ( word, "%f%n", &rval, &width );
			  
			  if ( count > 0 ) {
				  
				  // if ( normal_num_temp < ORDER_MAX * FACE_MAX ) 
				  {
					  normal_temp[normal_num_temp][ixyz] = rval;
					  ixyz = ixyz + 1;
					  if ( ixyz == 3 ) {
						  ixyz = 0;
						  normal_num_temp = normal_num_temp + 1;
					  }
				  }
			  }
			  else {
				  ++bad_num;
				  printf ( "NORMAL VECTOR: bad data %s\n", word );
			  }
		  }
      }
	  /*
	  (vertexproperty) VERTEX
	  */
      else if ( leqi ( level_name[level], "VERTEX" )  ) {
		  
		  if ( leqi ( level_name[level-1], "VERTEXPROPERTY" )  ) {
			  
			  if ( strcmp ( word, "[" ) == 0 ) {
				  ixyz = 0;
				  cor3_num_old = cor3_num;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  count = sscanf ( word, "%f%n", &rval, &width );
				  
				  if ( count > 0 ) {
					  
//					  if ( cor3_num < COR3_MAX ) 
					  {
						  cor3[cor3_num][ixyz] = rval;
					  }
					  ixyz = ixyz + 1;
					  if ( ixyz == 3 ) {
						  ixyz = 0;
						  cor3_num = cor3_num + 1;
					  }
					  
				  }
				  else {
					  ++bad_num;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
      }
	  /*
	  (indexedtrianglestripset) VERTEXPROPERTY
	  */
      else if ( leqi ( level_name[level], "VERTEXPROPERTY" )  ) {
		  
		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VERTEX" )  ) {
		  }
		  else if ( leqi ( word, "NORMAL" )  ) {
			  ixyz = 0;
		  }
		  else if ( leqi ( word, "MATERIALBINDING" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "NORMALBINDING" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
			  ++bad_num;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  VKNOTVECTOR
	  */
      else if ( leqi ( level_name[level], "VKNOTVECTOR" )  ) {
		  
		  if ( strcmp ( word, "[" ) == 0 ) {
			  continue;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
			  continue;
		  }
		  else {
			  count = sscanf ( word, "%d%n", &jval, &width );
		  }
      }
	  /*
	  Any other word:
	  */
      else {
      }
    }
  }
  /*
  Reset the transformation matrix to the identity,
  because, presumably, we've applied it by now.
  */
  tmat_init ( transform_matrix );
  
  return true;
}
/******************************************************************************/
#if 0
bool IVCONV::iv_write_old ( FILE *fileout )

/******************************************************************************/

/*
Purpose:

  IV_WRITE writes graphics information to an Inventor file.
  
	Modified:
	
	  29 June 1999
	  
		Author:
		
		  John Burkardt
		  */
{
	int icor3;
	int iface;
	int itemp;
	int ivert;
	int j;
	int length;
	int text_num;
	
	text_num = 0;
	
	fprintf ( fileout, "#Inventor V2.0 ascii\n" );
	fprintf ( fileout, "\n" );
	fprintf ( fileout, "Separator {\n" );
	fprintf ( fileout, "  Info {\n" );
	fprintf ( fileout, "    string \"%s generated by IVCON.\"\n", fileout_name );
	fprintf ( fileout, "    string \"Original data in file %s.\"\n", filein_name );
	fprintf ( fileout, "  }\n" );
	fprintf ( fileout, "  Separator {\n" );
	text_num = text_num + 8;
	/*
	LightModel:
	
	  BASE_COLOR ignores light sources, and uses only diffuse color
      and transparency.  Even without normal vector information,
      the object will show up.  However, you won't get shadow
      and lighting effects.
	  
		PHONG uses the Phong lighting model, accounting for light sources
		and surface orientation.  This is the default.  I believe
		you need accurate normal vector information in order for this
		option to produce nice pictures.
		
		  DEPTH ignores light sources, and calculates lighting based on
		  the location of the object within the near and far planes
		  of the current camera's view volume.
	*/
	fprintf ( fileout, "    LightModel {\n" );
	fprintf ( fileout, "      model PHONG\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 3;
	/*
	Transformation matrix.
	*/
	fprintf ( fileout, "    MatrixTransform { matrix\n" );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[0][0],
		transform_matrix[0][1], transform_matrix[0][2], transform_matrix[0][3] );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[1][0],
		transform_matrix[1][1], transform_matrix[1][2], transform_matrix[1][3] );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[2][0],
		transform_matrix[2][1], transform_matrix[2][2], transform_matrix[2][3] );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[3][0],
		transform_matrix[3][1], transform_matrix[3][2], transform_matrix[3][3] );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 6;
	/*
	Material.
	*/
	fprintf ( fileout, "    Material {\n" );
	fprintf ( fileout, "      ambientColor  0.2 0.2 0.2\n" );
	fprintf ( fileout, "      diffuseColor  0.8 0.8 0.8\n" );
	fprintf ( fileout, "      emissiveColor 0.0 0.0 0.0\n" );
	fprintf ( fileout, "      specularColor 0.0 0.0 0.0\n" );
	fprintf ( fileout, "      shininess     0.2\n" );
	fprintf ( fileout, "      transparency  0.0\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 8;
	/*
	MaterialBinding
	*/
	fprintf ( fileout, "    MaterialBinding {\n" );
	fprintf ( fileout, "      value PER_VERTEX_INDEXED\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 3;
	/*
	NormalBinding
	
	  PER_VERTEX promises that we will write a list of normal vectors
	  in a particular order, namely, the normal vectors for the vertices
	  of the first face, then the second face, and so on.
	  
		PER_VERTEX_INDEXED promises that we will write a list of normal vectors,
		and then, as part of the IndexedFaceSet, we will give a list of
		indices referencing this normal vector list.
	*/
	fprintf ( fileout, "    NormalBinding {\n" );
	fprintf ( fileout, "      value PER_VERTEX_INDEXED\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 3;
	/*
	Texture2.
	
	  FLAW: We can only handle on texture right now.
	*/
	if ( texture_num > 0 ) {
		fprintf ( fileout, "    Texture2 {\n" );
		fprintf ( fileout, "      filename \"%s\"\n", texture_name[0] );
		fprintf ( fileout, "      wrapS       REPEAT\n" );
		fprintf ( fileout, "      wrapT       REPEAT\n" );
		fprintf ( fileout, "      model       MODULATE\n" );
		fprintf ( fileout, "      blendColor  0.0 0.0 0.0\n" );
		fprintf ( fileout, "    }\n" );
		text_num = text_num + 7;
	}
	/*
	TextureCoordinateBinding
	*/
	fprintf ( fileout, "    TextureCoordinateBinding {\n" );
	fprintf ( fileout, "      value PER_VERTEX_INDEXED\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 3;
	/*
	ShapeHints
	*/
	fprintf ( fileout, "    ShapeHints {\n" );
	fprintf ( fileout, "      vertexOrdering COUNTERCLOCKWISE\n" );
	fprintf ( fileout, "      shapeType UNKNOWN_SHAPE_TYPE\n" );
	fprintf ( fileout, "      faceType CONVEX\n" );
	fprintf ( fileout, "      creaseAngle 6.28319\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 6;
	/*
	Point coordinates.
	*/
	fprintf ( fileout, "    Coordinate3 {\n" );
	fprintf ( fileout, "      point [\n" );
	text_num = text_num + 2;
	
	for ( j = 0; j < cor3_num; ++j ) {
		fprintf ( fileout, "        %f %f %f,\n", cor3[j][0], cor3[j][1], cor3[j][2] );
		++text_num;
	}
	fprintf ( fileout, "      ]\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 2;
	/*
	Texture coordinates.
	*/
	fprintf ( fileout, "    TextureCoordinate2 {\n" );
	fprintf ( fileout, "      point [\n" );
	text_num = text_num + 2;
	
	for ( iface = 0; iface < face_num; iface++ ) {
		for ( ivert = 0; ivert < face_order[iface]; ivert++ ) {
			fprintf ( fileout, "        %f %f,\n", vertex_tex_uv[iface][ivert][0], 
				vertex_tex_uv[iface][ivert][1] );
			++text_num;
		}
	}
	fprintf ( fileout, "      ]\n" );
	fprintf ( fileout, "    }\n" );
	text_num = text_num + 2;
	/*
	BaseColor.
	*/
	if ( color_num > 0 ) {
		
		fprintf ( fileout, "    BaseColor {\n" );
		fprintf ( fileout, "      rgb [\n" );
		text_num = text_num + 2;
		
		for ( j = 0; j < color_num; ++j ) {
			fprintf ( fileout, "        %f %f %f,\n", rgbcolor[j][0], rgbcolor[j][1], 
				rgbcolor[j][2] );
			++text_num;
		}
		
		fprintf ( fileout, "      ]\n" );
		fprintf ( fileout, "    }\n" );
		text_num = text_num + 2;
	}
	/*
	Normal vectors.
    Use the normal vectors associated with nodes.
	*/
	if ( face_num > 0 ) {
		
		fprintf ( fileout, "    Normal { \n" );
		fprintf ( fileout, "      vector [\n" );
		text_num = text_num + 2;
		
		for ( icor3 = 0; icor3 < cor3_num; icor3++ ) {
			fprintf ( fileout, "        %f %f %f,\n", 
				cor3_normal[icor3][0], 
				cor3_normal[icor3][1], 
				cor3_normal[icor3][2] );
			++text_num;
		}
		
		fprintf ( fileout, "      ]\n" );
		fprintf ( fileout, "    }\n" );
		text_num = text_num + 2;
	}
	/*
	IndexedLineSet
	*/
	if ( line_num > 0 ) {
		
		fprintf ( fileout, "    IndexedLineSet {\n" );
		/*
		IndexedLineSet coordIndex
		*/
		fprintf ( fileout, "      coordIndex [\n" );
		text_num = text_num + 2;
		
		length = 0;
		
		for ( j = 0; j < line_num; ++j ) {
			
			if ( length == 0 ) {
				fprintf ( fileout, "       " );
			}
			
			fprintf ( fileout, " %d,", line_dex[j] );
			length = length + 1;
			
			if ( line_dex[j] == -1 || length >= 10 || j == line_num-1 ) {
				fprintf ( fileout, "\n" );
				++text_num;
				length = 0;
			}
		}
		
		fprintf ( fileout, "      ]\n" );
		++text_num;
		/*
		IndexedLineSet materialIndex.
		*/
		fprintf ( fileout, "      materialIndex [\n" );
		++text_num;
		
		length = 0;
		
		for ( j = 0; j < line_num; ++j ) {
			
			if ( length == 0 ) {
				fprintf ( fileout, "       " );
			}
			
			fprintf ( fileout, " %d,", line_material[j] );
			length = length + 1;
			
			if ( line_material[j] == -1 || length >= 10 || j == line_num-1 ) {
				fprintf ( fileout, "\n" );
				++text_num;
				length = 0;
			}
		}
		
		fprintf ( fileout, "      ]\n" );
		fprintf ( fileout, "    }\n" );
		text_num = text_num + 2;
	}
	/*
	IndexedFaceSet.
	*/
	if ( face_num > 0 ) {
		
		fprintf ( fileout, "    IndexedFaceSet {\n" );
		fprintf ( fileout, "      coordIndex [\n" );
		text_num = text_num + 2;
		
		for ( iface = 0; iface < face_num; iface++ ) {
			
			fprintf ( fileout, "       " );
			
			for ( ivert = 0; ivert < face_order[iface]; ivert++ ) {
				fprintf ( fileout, " %d,", face[ivert][iface] );
			}
			fprintf ( fileout, " -1,\n" );
			++text_num;
		}
		
		fprintf ( fileout, "      ]\n" );
		++text_num;
		/*
		IndexedFaceSet normalIndex
		*/
		fprintf ( fileout, "      normalIndex [\n" );
		++text_num;
		
		for ( iface = 0; iface < face_num; iface++ ) {
			
			fprintf ( fileout, "       " );
			
			for ( ivert = 0; ivert < face_order[iface]; ivert++ ) {
				fprintf ( fileout, " %d,", face[ivert][iface] );
			}
			fprintf ( fileout, " -1,\n" );
			++text_num;
		}
		fprintf ( fileout, "      ]\n" );
		++text_num;
		/*
		IndexedFaceSet materialIndex
		*/
		fprintf ( fileout, "      materialIndex [\n" );
		++text_num;
		
		for ( iface = 0; iface < face_num; iface++ ) {
			
			fprintf ( fileout, "       " );
			
			for ( ivert = 0; ivert < face_order[iface]; ivert++ ) {
				fprintf ( fileout, " %d,", vertex_material[ivert][iface] );
			}
			fprintf ( fileout, " -1,\n" );
			++text_num;
		}
		
		fprintf ( fileout, "      ]\n" );
		++text_num;
		/*
		IndexedFaceSet textureCoordIndex
		*/
		fprintf ( fileout, "      textureCoordIndex [\n" );
		++text_num;
		
		itemp = 0;
		
		for ( iface = 0; iface < face_num; iface++ ) {
			
			fprintf ( fileout, "       " );
			
			for ( ivert = 0; ivert < face_order[iface]; ivert++ ) {
				fprintf ( fileout, " %d,", itemp );
				itemp = itemp + 1;
			}
			fprintf ( fileout, " -1,\n" );
			++text_num;
		}
		
		fprintf ( fileout, "      ]\n" );
		
		fprintf ( fileout, "    }\n" );
		text_num = text_num + 2;
	}
	/*
	Close up the Separator nodes.
	*/
	fprintf ( fileout, "  }\n" );
	fprintf ( fileout, "}\n" );
	text_num = text_num + 2;
	/*
	Report.
	*/
	printf ( "\n" );
	printf ( "IV_WRITE - Wrote %d text lines;\n", text_num );
	
	return true;
}

#endif



#include <Inventor/nodes/SoScale.h>
#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/nodes/SoCoordinate3.h>
#include <Inventor/nodes/SoCoordinate4.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoCone.h>
#include <Inventor/nodes/SoCylinder.h>
#include <Inventor/nodes/SoFaceSet.h>
#include <Inventor/nodes/SoIndexedFaceSet.h>
#include <Inventor/nodes/SoIndexedLineSet.h>
#include <Inventor/nodes/SoIndexedTriangleStripSet.h>
#include <Inventor/nodes/SoLightModel.h>
#include <Inventor/nodes/SoLineSet.h>
#include <Inventor/nodes/SoLOD.h>
#include <Inventor/nodes/SoLevelOfDetail.h>
#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/nodes/SoMatrixTransform.h>
#include <Inventor/nodes/SoNode.h>
#include <Inventor/nodes/SoNormal.h>
#include <Inventor/nodes/SoNormalBinding.h>
#include <Inventor/nodes/SoPointSet.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoShapeHints.h>
#include <Inventor/nodes/SoSphere.h>
#include <Inventor/nodes/SoTexture2.h>
#include <Inventor/nodes/SoTextureCoordinate2.h>
#include <Inventor/nodes/SoTextureCoordinateEnvironment.h>
#include <Inventor/nodes/SoTransform.h>
#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoTriangleStripSet.h>
#include <Inventor/fields/SoFields.h>
#include <Inventor/actions/SoWriteAction.h>
#ifdef __COIN__
#include <Inventor/nodes/SoTextureCoordinate3.h>
#include <Inventor/nodes/SoTransparencyType.h>
#include <Inventor/VRMLnodes/SoVRMLBillboard.h>
#endif
//#include <Inventor/Qt/SoQt.h>
#include <Inventor/nodekits/SoNodeKit.h>

/**
 * using SoQt (Coin) to write inventor file
 * Author: Jennifer Buehler
 * Date: March 2014
 */ 
bool IVCONV::iv_write ( FILE *fileout ) {

	//SoQt::init("Dummy");
	SoNodeKit::init();

	SoSeparator *ivRoot;

	// Scene root
	ivRoot = new SoSeparator;
	ivRoot->ref();

	float sf=SCALE_FACTOR; //scale factor for all meshes and transforms

	printf("Scaling: %f\n",SCALE_FACTOR);
	
	/*
	fprintf ( fileout, "#Inventor V2.0 ascii\n" );
	fprintf ( fileout, "\n" );
	fprintf ( fileout, "Separator {\n" );
	fprintf ( fileout, "  Info {\n" );
	fprintf ( fileout, "    string \"%s generated by IVCON.\"\n", fileout_name );
	fprintf ( fileout, "    string \"Original data in file %s.\"\n", filein_name );
	fprintf ( fileout, "  }\n" );
	fprintf ( fileout, "  Separator {\n" );
	text_num = text_num + 8;
	*/


	/*
	LightModel:
	
	  BASE_COLOR ignores light sources, and uses only diffuse color
      and transparency.  Even without normal vector information,
      the object will show up.  However, you won't get shadow
      and lighting effects.
	  
		PHONG uses the Phong lighting model, accounting for light sources
		and surface orientation.  This is the default.  I believe
		you need accurate normal vector information in order for this
		option to produce nice pictures.
		
		  DEPTH ignores light sources, and calculates lighting based on
		  the location of the object within the near and far planes
		  of the current camera's view volume.
	*/


	SoLightModel *lightModel = new SoLightModel;
	lightModel->model = SoLightModel::PHONG;

	bool writeIndexed=false;


	// OSG -> Inventor coordinate system conversion
	SoMatrixTransform *matrixTransform = new SoMatrixTransform;
	matrixTransform->matrix.setValue(
		transform_matrix[0][0], transform_matrix[0][1], transform_matrix[0][2], transform_matrix[0][3]*sf,
		transform_matrix[1][0], transform_matrix[1][1], transform_matrix[1][2], transform_matrix[1][3]*sf,
		transform_matrix[2][0], transform_matrix[2][1], transform_matrix[2][2], transform_matrix[2][3]*sf,
		transform_matrix[3][0], transform_matrix[3][1], transform_matrix[3][2], transform_matrix[3][3] );


	//Material.
	// Put default material
	SoMaterial * globalMaterial=new SoMaterial();
	globalMaterial->ambientColor.setValue(0.2,0.2,0.2);
	globalMaterial->diffuseColor.setValue(0.5,0.5,0.9);
	globalMaterial->emissiveColor.setValue(0,0,0);
	globalMaterial->specularColor.setValue(0,0,0);
	//globalMaterial->shininess.setNum(0.2);
	//globalMaterial->transparency.setNum(0);
	
	SoMaterialBinding * materialBinding=new SoMaterialBinding();
	if (writeIndexed) 
		materialBinding->value=SoMaterialBinding::PER_VERTEX_INDEXED;
	else	
		//materialBinding->value=SoMaterialBinding::PER_VERTEX;
		materialBinding->value=SoMaterialBinding::OVERALL;



	/*
	NormalBinding
	  PER_VERTEX promises that we will write a list of normal vectors
	  in a particular order, namely, the normal vectors for the vertices
	  of the first face, then the second face, and so on.
	  
		PER_VERTEX_INDEXED promises that we will write a list of normal vectors,
		and then, as part of the IndexedFaceSet, we will give a list of
		indices referencing this normal vector list.
	*/
	SoNormalBinding * normalBinding=new SoNormalBinding();
	if (writeIndexed) 
		normalBinding->value=SoNormalBinding::PER_VERTEX_INDEXED;
	else	normalBinding->value=SoNormalBinding::PER_VERTEX;
	
	

	//XXX FLAW: No textures handeled yet.
	// Make sure texturing is OFF
	//ivRoot->addChild(new SoTexture2());

	//ShapeHints
	//              Inventor defaults to:
	// lighting:    one side lighting
	// frontFace:   COUNTER_CLOCKWISE
	// culling:     DISABLED
	// faceCulling: GL_BACK
	SoShapeHints *shapeHints = new SoShapeHints();
	shapeHints->vertexOrdering = SoShapeHints::COUNTERCLOCKWISE;
	shapeHints->shapeType = SoShapeHints::SOLID; // SOLID, SHAPE_TYPE_AS_IS, UNKNOWN_SHAPE_TYPE
	shapeHints->faceType = SoShapeHints::UNKNOWN_FACE_TYPE; //, CONVEX, FACE_TYPE_AS_IS,UNKNOWN_FACE_TYPE


	//Point coordinates.
	SoFaceSet * faceSet = new SoFaceSet();
	SoIndexedFaceSet * idxFaceSet= new SoIndexedFaceSet();
	
	SoVertexProperty * vProp = new SoVertexProperty();
	SoCoordinate3 *coord = new SoCoordinate3();
	SoNormal *normals = new SoNormal();
	SoBaseColor * color= new SoBaseColor();	

	if (writeIndexed) {
		vProp->vertex.setNum(cor3_num); //SoMFVec3f point
		coord->point.setNum(cor3_num); 
		for (int j = 0; j < cor3_num; ++j ) {
			vProp->vertex.set1Value(j,cor3[j][0]*sf, cor3[j][1]*sf, cor3[j][2]*sf);
			coord->point.set1Value(j,cor3[j][0]*sf, cor3[j][1]*sf, cor3[j][2]*sf);
		}
		//BaseColor.
		if ( color_num > 0 ) {
			for ( int j = 0; j < color_num; ++j ) {
				color->rgb.set1Value(j,rgbcolor[j][0], rgbcolor[j][1], rgbcolor[j][2] );
			}
		}

		
		if ( face_num > 0 ) {
			//Normal vectors. Use the normal vectors associated with nodes.
			vProp->normal.setNum(cor3_num); //SoMFVec3f point
			for ( int icor3 = 0; icor3 < cor3_num; icor3++ ) {
				vProp->normal.set1Value(icor3,cor3_normal[icor3][0], cor3_normal[icor3][1], cor3_normal[icor3][2] );
				normals->vector.set1Value(icor3,cor3_normal[icor3][0], cor3_normal[icor3][1], cor3_normal[icor3][2] );
			}
			vProp->normalBinding.setValue(SoNormalBinding::PER_VERTEX_INDEXED);

			//IndexedFaceSet.
			int idxCnt=0;
			for ( int iface = 0; iface < face_num; iface++ ) {
				//printf("Setting %i\n",face_order[iface]);
				for ( int ivert = 0; ivert < face_order[iface]; ivert++ ) {
					idxFaceSet->coordIndex.set1Value(idxCnt,face[ivert][iface]);
					idxFaceSet->normalIndex.set1Value(idxCnt,face[ivert][iface]);
					idxFaceSet->materialIndex.set1Value(idxCnt,vertex_material[ivert][iface]);
					++idxCnt;
				}
				idxFaceSet->coordIndex.set1Value(idxCnt,SO_END_FACE_INDEX);
				idxFaceSet->normalIndex.set1Value(idxCnt,SO_END_FACE_INDEX);
				idxFaceSet->materialIndex.set1Value(idxCnt,SO_END_FACE_INDEX);
				++idxCnt;
			}
		}
	}else {
		if (face_num <=0 ){
			printf("WARN: No faces to be generated");
		}
	
		//BaseColor.
		if ( color_num > 0 ) {
			for ( int j = 0; j < color_num; ++j ) {
				color->rgb.set1Value(j,rgbcolor[j][0], rgbcolor[j][1], rgbcolor[j][2] );
			}
		}

		if ( face_num > 0 ) {
			long int cntTotalVertex=0;
			for ( int iface = 0; iface < face_num; iface++ ) {
				cntTotalVertex+=face_order[iface];
			}


			int idxCnt=0;

			coord->point.setNum(cntTotalVertex); 
			vProp->normal.setNum(cntTotalVertex);
			printf("Total vertex count: %li\n",cntTotalVertex);
 
			for ( int iface = 0; iface < face_num; iface++ ) {
				for ( int ivert = 0; ivert < face_order[iface]; ivert++ ) {
					long int pi=face[ivert][iface];
					vProp->vertex.set1Value(idxCnt,cor3[pi][0]*sf, cor3[pi][1]*sf, cor3[pi][2]*sf);
					coord->point.set1Value(idxCnt,cor3[pi][0]*sf, cor3[pi][1]*sf, cor3[pi][2]*sf);
					vProp->normal.set1Value(idxCnt,cor3_normal[pi][0], cor3_normal[pi][1], cor3_normal[pi][2]);
					normals->vector.set1Value(idxCnt,cor3_normal[pi][0], cor3_normal[pi][1], cor3_normal[pi][2]);
					++idxCnt;
				}
			}
			vProp->normalBinding.setValue(SoNormalBinding::PER_VERTEX);

					
			//FaceSet.
			for ( int iface = 0; iface < face_num; iface++ ) {
				//printf("Setting %i\n",face_order[iface]);
				faceSet->numVertices.set1Value(iface,face_order[iface]);
			}

		
			/*idxCnt=0;
			for ( int iface = 0; iface < face_num; iface++ ) {
				for ( int ivert = 0; ivert < face_order[iface]; ivert++ ) {
					idxFaceSet->materialIndex.set1Value(idxCnt,vertex_material[ivert][iface]);
					++idxCnt;
				}
				idxFaceSet->materialIndex.set1Value(idxCnt,SO_END_FACE_INDEX);
				++idxCnt;
			}*/
		}

	}


#if 0
	faceSet->vertexProperty.setValue(vProp);
	ivRoot->addChild(faceSet);
	ivRoot->addChild(materialBinding);
	ivRoot->addChild(normalBinding);
#else

	//ivRoot->addChild(matrixTransform);
	SoSeparator * meshSummary = new SoSeparator();
	meshSummary->addChild(shapeHints);
	meshSummary->addChild(globalMaterial);
	meshSummary->addChild(materialBinding);
	
	SoSeparator * mesh = new SoSeparator();
	mesh->addChild(normals);
	mesh->addChild(normalBinding);
	mesh->addChild(coord);
	//mesh->addChild(color);
	if (writeIndexed) mesh->addChild(idxFaceSet);
	else mesh->addChild(faceSet);

	meshSummary->addChild(mesh);
	
	SoGroup * group = new SoGroup();
	group->addChild(meshSummary);
	//ivRoot->addChild(lightModel);

	ivRoot->addChild(group);
	
#endif
	
	SoOutput out;
	out.setBinary(false);
	out.setFilePointer(fileout);
	SoWriteAction write(&out);
	write.apply(ivRoot);
	write.getOutput()->closeFile();
	printf ( "IV_WRITE - Success;\n");

	return true;
}
